package lib

import (
	"fmt"
	"strings"

	oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

type restoreOptionType struct {
	ctnu     bool
	reporter *Reporter
}

var specChineseRestore = SpecText{

	synopsisText: "恢复冷冻状态的Objects为读就绪状态",

	paramText: "[cloud_url] [options]",

	syntaxText: ` 
    ossutil restore cloud_url [--encoding-type url] [-r] [-f] [--output-dir=odir] [-c file] 
`,

	detailHelpText: ` 
    该命令恢复处于冷冻状态的归档类型object进入读就绪状态，即操作对象object必须为` + StorageArchive + `存储
    类型的object。

    如果是针对处于冷冻状态的归档类型object第一次调用restore接口，则返回成功。
    如果已经成功调用过restore接口，且restore没有完全完成，再次调用时同样成功。
    如果已经成功调用过restore接口，且restore已经完成，再次调用时返回成功，且会将object
    的可下载时间延长一天，最多延长7天。

--recursive选项：

    在进行批量恢复时，如果其中某个object操作失败，ossutil不会退出，而是继续进行其他object
    的恢复动作，并将出错文件的错误信息记录到report文件中。成功恢复的object信息将不会被
    记录到report文件中。

    注意：批量操作出错时不继续运行，而是终止运行的情况：
    （1）如果未进入批量object恢复的迭代过程，错误已经发生，则不会产生report文件，ossutil
    会终止运行，不继续迭代过程。如，用户输入cp命令出错时，不会产生report文件，而是屏幕输
    出错误并退出。
    （2）如果批量操作过程某object发生的错误为：Bucket不存在、accessKeyID/accessKeySecret
    错误造成的权限验证非法等错误，ossutil会屏幕输出错误并退出。

    report文件名为：` + ReportPrefix + `日期_时间` + ReportSuffix + `。report文件是ossutil输出文件的一种，
    被放置在ossutil的输出目录下，该目录的路径可以用配置文件中的outputDir选项或命令行
    --output-dir选项指定，如果未指定，会使用默认的输出目录：当前目录下的` + DefaultOutputDir + `目录。

    注意：ossutil不做report文件的维护工作，请自行查看及清理用户的report文件，避免产生
    过多的report文件。

--output-dir选项
    
    该选项指定ossutil输出文件存放的目录，默认为：当前目录下的` + DefaultOutputDir + `目录。如果指定
    的目录不存在，ossutil会自动创建该目录，如果用户指定的路径已存在并且不是目录，会报错。
    输出文件表示ossutil在运行过程中产生的输出文件，目前包含：在cp命令中ossutil运行出错时
    产生的report文件，在批量restore出错时产生的report文件。


用法：

    该命令有两种用法：

    1) ossutil restore oss://bucket/object [--encoding-type url] 
        该用法恢复单个冷冻状态object为读就绪状态，当指定object不存在时，ossutil会提示错
    误，此时请确保指定的url精确匹配需要设置acl的object，并且不要指定--recursive选项（否
    则ossutil会进行前缀匹配，恢复多个冷冻状态的objects为读就绪状态）。无论--force选项是
    否指定，都不会进行询问提示。

    2) ossutil restore oss://bucket[/prefix] -r [--encoding-type url] [-f] [--output-dir=odir]
        该用法可批量恢复多个冷冻状态的objects为读就绪状态，此时必须输入--recursive选项，
    ossutil会查找所有前缀匹配url的objects，恢复它们为读就绪状态。当某个object的恢复出现
    错误时会继续恢复其他object。如果--force选项被指定，则不会进行询问提示。
`,

	sampleText: ` 
    1) ossutil restore oss://bucket-restore/object-store
    2) ossutil restore oss://bucket-restore/object-prefix -r
    3) ossutil restore oss://bucket-restore/object-prefix -r -f
    4) ossutil restore oss://bucket-restore/%e4%b8%ad%e6%96%87 --encoding-type url
`,
}

var specEnglishRestore = SpecText{

	synopsisText: "Restore Frozen State Object to Read Ready Status",

	paramText: "[cloud_url] [options]",

	syntaxText: ` 
    ossutil restore cloud_url [--encoding-type url] [-r] [-f] [--output-dir=odir] [-c file] 
`,

	detailHelpText: ` 
    The command restore frozen state object to read ready status, the object must be in 
    the storage class of ` + StorageArchive + `. 

    If it's the first time to restore a frozen state object, the operation will success.
    If the object is in restoring, and the restoring is not finished, do the operation 
    again will success.
    If an object has been restored, do the operation again will success, and the time that 
    the object can be downloaded will extend one day, we can at most extend seven days. 

--recursive option:

    By default, if an error occurs to a object in batch restore objects operation, ossutil 
    will continue to attempt to restore the remaining objects, and ossutil will record the
    error message to report file. The objects succeed copied will not be recorded to report 
    file.

    Note: Ossutil will print error information and exit, instead of continue to run if an 
    error occurs in batch restore objects operation in several situations:
    (1) If the error occurs before of entering the restore iteration, ossutil will print 
        error message and return, and the report file will not be generated. eg. user enter
        an invalid cp command.
    (2) If the error occurs during restore iteration is: NoSuchBucket, AccessDenied caused 
        by unauthorized authentication and other errors. ossutil will print error message
        and return, the report file that has been generated will not be deleted.

    Report file name is: ` + ReportPrefix + `Date_Time` + ReportSuffix + `. Report file is one kind of output 
    files, and will be putted in output directory, the directory can be specified by --output-dir 
    option or outputDir option in config file. If it's not specified, ossutil will use the 
    default directory: ` + DefaultOutputDir + ` in current directory.

    Note: ossutil will not mainten the report file, please check and clear your output directory
    regularlly to avoid too many report files in your output directory.

--output-dir option
    
    The option specify the directory to deposit output file generated by ossutil, the default 
    value is: ` + DefaultOutputDir + ` in current directory. If the directory specified not exist, ossutil 
    will create the directory automatically, if it exists but is not a directory, ossutil will 
    return an error.  

    Output file contains: report file which used to record error message generated by cp command 
    and restore command.


Usage:

    There are two usages:

    1) ossutil restore oss://bucket/object [--encoding-type url] 
        If --recursive option is not specified, ossutil restore the specified single frozen state 
    object to read ready status. In the usage, please make sure url exactly specified the object 
    you want to restore, if object not exist, error occurs. No matter --force option is specified 
    or not, ossutil will not show prompt question. 

    2) ossutil restore oss://bucket[/prefix] -r [--encoding-type url] [-f] [--output-dir=odir]
        The usage can restore many objects that in frozen state to read ready status, --recursive 
    option is required for the usage, ossutil will search for prefix-matching objects and restore 
    those objects. When an error occurs when restore an object, ossutil continue to restore other 
    objects. If --force option is specified, ossutil will not show prompt question. 
`,

	sampleText: ` 
    1) ossutil restore oss://bucket-restore/object-store
    2) ossutil restore oss://bucket-restore/object-prefix -r
    3) ossutil restore oss://bucket-restore/object-prefix -r -f
    4) ossutil restore oss://bucket-restore/%e4%b8%ad%e6%96%87 --encoding-type url
`,
}

// RestoreCommand is the command list buckets or objects
type RestoreCommand struct {
	command  Command
	reOption restoreOptionType
	monitor  Monitor
}

var restoreCommand = RestoreCommand{
	command: Command{
		name:        "restore",
		nameAlias:   []string{},
		minArgc:     1,
		maxArgc:     1,
		specChinese: specChineseRestore,
		specEnglish: specEnglishRestore,
		group:       GroupTypeNormalCommand,
		validOptionNames: []string{
			OptionRecursion,
			OptionForce,
			OptionEncodingType,
			OptionConfigFile,
			OptionEndpoint,
			OptionAccessKeyID,
			OptionAccessKeySecret,
			OptionSTSToken,
			OptionRetryTimes,
			OptionRoutines,
			OptionOutputDir,
		},
	},
}

// function for FormatHelper interface
func (rc *RestoreCommand) formatHelpForWhole() string {
	return rc.command.formatHelpForWhole()
}

func (rc *RestoreCommand) formatIndependHelp() string {
	return rc.command.formatIndependHelp()
}

// Init simulate inheritance, and polymorphism
func (rc *RestoreCommand) Init(args []string, options OptionMapType) error {
	return rc.command.Init(args, options, rc)
}

// RunCommand simulate inheritance, and polymorphism
func (rc *RestoreCommand) RunCommand() error {
	rc.monitor.init("Restored")

	encodingType, _ := GetString(OptionEncodingType, rc.command.options)
	recursive, _ := GetBool(OptionRecursion, rc.command.options)

	cloudURL, err := CloudURLFromString(rc.command.args[0], encodingType)
	if err != nil {
		return err
	}

	if err = rc.checkArgs(cloudURL, recursive); err != nil {
		return err
	}

	bucket, err := rc.command.ossBucket(cloudURL.bucket)
	if err != nil {
		return err
	}

	if !recursive {
		return rc.ossRestoreObject(bucket, cloudURL.object)
	}
	return rc.batchRestoreObjects(bucket, cloudURL)
}

func (rc *RestoreCommand) checkArgs(cloudURL CloudURL, recursive bool) error {
	if cloudURL.bucket == "" {
		return fmt.Errorf("invalid cloud url: %s, miss bucket", rc.command.args[0])
	}
	if !recursive && cloudURL.object == "" {
		return fmt.Errorf("restore object invalid cloud url: %s, object empty. Restore bucket is not supported, if you mean batch restore objects, please use --recursive", rc.command.args[0])
	}
	return nil
}

func (rc *RestoreCommand) ossRestoreObject(bucket *oss.Bucket, object string) error {
	retryTimes, _ := GetInt(OptionRetryTimes, rc.command.options)
	for i := 1; ; i++ {
		err := bucket.RestoreObject(object)
		if err == nil {
			return err
		}

		switch err.(type) {
		case oss.ServiceError:
			if err.(oss.ServiceError).StatusCode == 409 && err.(oss.ServiceError).Code == "RestoreAlreadyInProgress" {
				return nil
			}
		}

		if int64(i) >= retryTimes {
			return ObjectError{err, bucket.BucketName, object}
		}
	}
}

func (rc *RestoreCommand) batchRestoreObjects(bucket *oss.Bucket, cloudURL CloudURL) error {
	force, _ := GetBool(OptionForce, rc.command.options)
	if !force {
		var val string
		fmt.Printf("Do you really mean to recursivlly restore objects of %s(y or N)? ", rc.command.args[0])
		if _, err := fmt.Scanln(&val); err != nil || (strings.ToLower(val) != "yes" && strings.ToLower(val) != "y") {
			fmt.Println("operation is canceled.")
			return nil
		}
	}

	rc.reOption.ctnu = true
	outputDir, _ := GetString(OptionOutputDir, rc.command.options)

	// init reporter
	var err error
	if rc.reOption.reporter, err = GetReporter(rc.reOption.ctnu, outputDir, commandLine); err != nil {
		return err
	}
	defer rc.reOption.reporter.Clear()

	return rc.restoreObjects(bucket, cloudURL)
}

func (rc *RestoreCommand) restoreObjects(bucket *oss.Bucket, cloudURL CloudURL) error {
	routines, _ := GetInt(OptionRoutines, rc.command.options)

	chObjects := make(chan string, ChannelBuf)
	chError := make(chan error, routines+1)
	chListError := make(chan error, 1)
	go rc.command.objectStatistic(bucket, cloudURL, &rc.monitor)
	go rc.command.objectProducer(bucket, cloudURL, chObjects, chListError)
	for i := 0; int64(i) < routines; i++ {
		go rc.restoreConsumer(bucket, cloudURL, chObjects, chError)
	}

	return rc.waitRoutinueComplete(chError, chListError, routines)
}

func (rc *RestoreCommand) restoreConsumer(bucket *oss.Bucket, cloudURL CloudURL, chObjects <-chan string, chError chan<- error) {
	for object := range chObjects {
		err := rc.restoreObjectWithReport(bucket, object)
		if err != nil {
			chError <- err
			if !rc.reOption.ctnu {
				return
			}
			continue
		}
	}

	chError <- nil
}

func (rc *RestoreCommand) restoreObjectWithReport(bucket *oss.Bucket, object string) error {
	err := rc.ossRestoreObject(bucket, object)
	rc.command.updateMonitor(err, &rc.monitor)
	msg := fmt.Sprintf("restore %s", CloudURLToString(bucket.BucketName, object))
	rc.report(msg, err)
	return err
}

func (rc *RestoreCommand) report(msg string, err error) {
	if rc.filterError(err) {
		rc.reOption.reporter.ReportError(fmt.Sprintf("%s error, info: %s", msg, err.Error()))
		rc.reOption.reporter.Prompt(err)
	}
}

func (rc *RestoreCommand) filterError(err error) bool {
	if err == nil {
		return false
	}

	err = err.(ObjectError).err

	switch err.(type) {
	case oss.ServiceError:
		code := err.(oss.ServiceError).Code
		if code == "NoSuchBucket" || code == "InvalidAccessKeyId" || code == "SignatureDoesNotMatch" || code == "AccessDenied" || code == "RequestTimeTooSkewed" || code == "InvalidBucketName" {
			rc.reOption.ctnu = false
			return false
		}
	}
	return true
}

func (rc *RestoreCommand) waitRoutinueComplete(chError, chListError <-chan error, routines int64) error {
	completed := 0
	var ferr error
	for int64(completed) <= routines {
		select {
		case err := <-chListError:
			if err != nil {
				return err
			}
			completed++
		case err := <-chError:
			if err == nil {
				completed++
			} else {
				ferr = err
				if !rc.reOption.ctnu {
					fmt.Printf(rc.monitor.newProgressBar(true, errExit))
					return err
				}
			}
		}
	}
	return rc.formatResultPrompt(ferr)
}

func (rc *RestoreCommand) formatResultPrompt(err error) error {
	fmt.Printf(rc.monitor.newProgressBar(true, normalExit))
	if err != nil && rc.reOption.ctnu {
		return nil
	}
	return err
}
